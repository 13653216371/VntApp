// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `VntApiCallbackInner` is not used by any `pub` functions, thus it is ignored.
// The functions `convert`, `clone`, `fmt`, `clone`, `success`, `create_tun`, `connect`, `handshake`, `register`, `peer_client_list`, `error`, `stop`, `fmt`, `from`, `fmt`, `from`, `fmt`, `from`, `fmt`, `from`, `fmt`, `fmt`, `from`, `from`, `fmt`, `from`, `fmt`, `from`, `fmt`, `from`, `fmt`, `from`, `fmt`, `from` are not `pub`, thus are ignored.

Future<VntApi> vntInit(
        {required VntConfig vntConfig, required VntApiCallback call}) =>
    RustLib.instance.api
        .crateApiVntApiVntInit(vntConfig: vntConfig, call: call);

Future<void> initLog() => RustLib.instance.api.crateApiVntApiInitLog();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VntApi>>
@sealed
class VntApi extends RustOpaque {
  // Not to be used by end users
  VntApi.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VntApi.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VntApi,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApi,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiPtr,
  );

  RustCurrentDeviceInfo currentDevice() =>
      RustLib.instance.api.crateApiVntApiVntApiCurrentDevice(
        that: this,
      );

  List<RustPeerClientInfo> deviceList() =>
      RustLib.instance.api.crateApiVntApiVntApiDeviceList(
        that: this,
      );

  String downStream() => RustLib.instance.api.crateApiVntApiVntApiDownStream(
        that: this,
      );

  Uint64List downStreamLine({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiDownStreamLine(that: this, ip: ip);

  String ipDownStreamTotal({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiIpDownStreamTotal(that: this, ip: ip);

  String ipUpStreamTotal({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiIpUpStreamTotal(that: this, ip: ip);

  bool isStopped() => RustLib.instance.api.crateApiVntApiVntApiIsStopped(
        that: this,
      );

  RustNatInfo natInfo() => RustLib.instance.api.crateApiVntApiVntApiNatInfo(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<VntApi> newInstance(
          {required VntConfig vntConfig, required VntApiCallback call}) =>
      RustLib.instance.api
          .crateApiVntApiVntApiNew(vntConfig: vntConfig, call: call);

  RustNatInfo? peerNatInfo({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiPeerNatInfo(that: this, ip: ip);

  RustRoute? route({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiRoute(that: this, ip: ip);

  List<(String, List<RustRoute>)> routeList() =>
      RustLib.instance.api.crateApiVntApiVntApiRouteList(
        that: this,
      );

  void stop() => RustLib.instance.api.crateApiVntApiVntApiStop(
        that: this,
      );

  List<(String, BigInt, BigInt)> streamAll() =>
      RustLib.instance.api.crateApiVntApiVntApiStreamAll(
        that: this,
      );

  String upStream() => RustLib.instance.api.crateApiVntApiVntApiUpStream(
        that: this,
      );

  Uint64List upStreamLine({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiUpStreamLine(that: this, ip: ip);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VntApiCallback>>
@sealed
class VntApiCallback extends RustOpaque {
  // Not to be used by end users
  VntApiCallback.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VntApiCallback.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VntApiCallback,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiCallback,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiCallbackPtr,
  );

  factory VntApiCallback(
          {required FutureOr<void> Function() successFn,
          required FutureOr<void> Function(RustDeviceInfo) createTunFn,
          required FutureOr<void> Function(RustConnectInfo) connectFn,
          required FutureOr<bool> Function(RustHandshakeInfo) handshakeFn,
          required FutureOr<bool> Function(RustRegisterInfo) registerFn,
          required FutureOr<int> Function(RustDeviceConfig) generateTunFn,
          required FutureOr<void> Function(List<RustPeerClientInfo>)
              peerClientListFn,
          required FutureOr<void> Function(RustErrorInfo) errorFn,
          required FutureOr<void> Function() stopFn}) =>
      RustLib.instance.api.crateApiVntApiVntApiCallbackNew(
          successFn: successFn,
          createTunFn: createTunFn,
          connectFn: connectFn,
          handshakeFn: handshakeFn,
          registerFn: registerFn,
          generateTunFn: generateTunFn,
          peerClientListFn: peerClientListFn,
          errorFn: errorFn,
          stopFn: stopFn);
}

class RustConnectInfo {
  final BigInt count;
  final String address;

  const RustConnectInfo({
    required this.count,
    required this.address,
  });

  @override
  int get hashCode => count.hashCode ^ address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustConnectInfo &&
          runtimeType == other.runtimeType &&
          count == other.count &&
          address == other.address;
}

class RustCurrentDeviceInfo {
  final String virtualIp;
  final String virtualNetmask;
  final String virtualGateway;
  final String virtualNetwork;
  final String broadcastIp;
  final String connectServer;
  final String status;

  const RustCurrentDeviceInfo({
    required this.virtualIp,
    required this.virtualNetmask,
    required this.virtualGateway,
    required this.virtualNetwork,
    required this.broadcastIp,
    required this.connectServer,
    required this.status,
  });

  @override
  int get hashCode =>
      virtualIp.hashCode ^
      virtualNetmask.hashCode ^
      virtualGateway.hashCode ^
      virtualNetwork.hashCode ^
      broadcastIp.hashCode ^
      connectServer.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustCurrentDeviceInfo &&
          runtimeType == other.runtimeType &&
          virtualIp == other.virtualIp &&
          virtualNetmask == other.virtualNetmask &&
          virtualGateway == other.virtualGateway &&
          virtualNetwork == other.virtualNetwork &&
          broadcastIp == other.broadcastIp &&
          connectServer == other.connectServer &&
          status == other.status;
}

class RustDeviceConfig {
  final String virtualIp;
  final String virtualNetmask;
  final String virtualGateway;
  final String virtualNetwork;
  final List<(String, String)> externalRoute;

  const RustDeviceConfig({
    required this.virtualIp,
    required this.virtualNetmask,
    required this.virtualGateway,
    required this.virtualNetwork,
    required this.externalRoute,
  });

  @override
  int get hashCode =>
      virtualIp.hashCode ^
      virtualNetmask.hashCode ^
      virtualGateway.hashCode ^
      virtualNetwork.hashCode ^
      externalRoute.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustDeviceConfig &&
          runtimeType == other.runtimeType &&
          virtualIp == other.virtualIp &&
          virtualNetmask == other.virtualNetmask &&
          virtualGateway == other.virtualGateway &&
          virtualNetwork == other.virtualNetwork &&
          externalRoute == other.externalRoute;
}

class RustDeviceInfo {
  final String name;
  final String version;

  const RustDeviceInfo({
    required this.name,
    required this.version,
  });

  @override
  int get hashCode => name.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustDeviceInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          version == other.version;
}

class RustErrorInfo {
  final RustErrorType code;
  final String? msg;

  const RustErrorInfo({
    required this.code,
    this.msg,
  });

  @override
  int get hashCode => code.hashCode ^ msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustErrorInfo &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          msg == other.msg;
}

enum RustErrorType {
  tokenError,
  disconnect,
  addressExhausted,
  ipAlreadyExists,
  invalidIp,
  localIpExists,
  unknown,
  ;
}

class RustHandshakeInfo {
  final String? finger;
  final String version;

  const RustHandshakeInfo({
    this.finger,
    required this.version,
  });

  @override
  int get hashCode => finger.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustHandshakeInfo &&
          runtimeType == other.runtimeType &&
          finger == other.finger &&
          version == other.version;
}

class RustNatInfo {
  final List<String> publicIps;
  final String natType;
  final String? localIpv4;
  final String? ipv6;

  const RustNatInfo({
    required this.publicIps,
    required this.natType,
    this.localIpv4,
    this.ipv6,
  });

  @override
  int get hashCode =>
      publicIps.hashCode ^
      natType.hashCode ^
      localIpv4.hashCode ^
      ipv6.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustNatInfo &&
          runtimeType == other.runtimeType &&
          publicIps == other.publicIps &&
          natType == other.natType &&
          localIpv4 == other.localIpv4 &&
          ipv6 == other.ipv6;
}

class RustPeerClientInfo {
  final String virtualIp;
  final String name;
  final String status;
  final bool clientSecret;

  const RustPeerClientInfo({
    required this.virtualIp,
    required this.name,
    required this.status,
    required this.clientSecret,
  });

  @override
  int get hashCode =>
      virtualIp.hashCode ^
      name.hashCode ^
      status.hashCode ^
      clientSecret.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustPeerClientInfo &&
          runtimeType == other.runtimeType &&
          virtualIp == other.virtualIp &&
          name == other.name &&
          status == other.status &&
          clientSecret == other.clientSecret;
}

class RustRegisterInfo {
  final String virtualIp;
  final String virtualNetmask;
  final String virtualGateway;

  const RustRegisterInfo({
    required this.virtualIp,
    required this.virtualNetmask,
    required this.virtualGateway,
  });

  @override
  int get hashCode =>
      virtualIp.hashCode ^ virtualNetmask.hashCode ^ virtualGateway.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustRegisterInfo &&
          runtimeType == other.runtimeType &&
          virtualIp == other.virtualIp &&
          virtualNetmask == other.virtualNetmask &&
          virtualGateway == other.virtualGateway;
}

class RustRoute {
  final String protocol;
  final String addr;
  final int metric;
  final PlatformInt64 rt;

  const RustRoute({
    required this.protocol,
    required this.addr,
    required this.metric,
    required this.rt,
  });

  @override
  int get hashCode =>
      protocol.hashCode ^ addr.hashCode ^ metric.hashCode ^ rt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustRoute &&
          runtimeType == other.runtimeType &&
          protocol == other.protocol &&
          addr == other.addr &&
          metric == other.metric &&
          rt == other.rt;
}

class VntConfig {
  final bool tap;
  final String token;
  final String deviceId;
  final String name;
  final String serverAddressStr;
  final List<String> nameServers;
  final List<String> stunServer;
  final List<(int, int, String)> inIps;
  final List<(int, int)> outIps;
  final String? password;
  final int? mtu;
  final String? ip;
  final bool noProxy;
  final bool serverEncrypt;
  final String cipherModel;
  final bool finger;
  final String punchModel;
  final Uint16List? ports;
  final bool firstLatency;
  final String? deviceName;
  final String useChannelType;
  final double? packetLossRate;
  final int packetDelay;
  final List<String> portMappingList;
  final String compressor;

  const VntConfig({
    required this.tap,
    required this.token,
    required this.deviceId,
    required this.name,
    required this.serverAddressStr,
    required this.nameServers,
    required this.stunServer,
    required this.inIps,
    required this.outIps,
    this.password,
    this.mtu,
    this.ip,
    required this.noProxy,
    required this.serverEncrypt,
    required this.cipherModel,
    required this.finger,
    required this.punchModel,
    this.ports,
    required this.firstLatency,
    this.deviceName,
    required this.useChannelType,
    this.packetLossRate,
    required this.packetDelay,
    required this.portMappingList,
    required this.compressor,
  });

  @override
  int get hashCode =>
      tap.hashCode ^
      token.hashCode ^
      deviceId.hashCode ^
      name.hashCode ^
      serverAddressStr.hashCode ^
      nameServers.hashCode ^
      stunServer.hashCode ^
      inIps.hashCode ^
      outIps.hashCode ^
      password.hashCode ^
      mtu.hashCode ^
      ip.hashCode ^
      noProxy.hashCode ^
      serverEncrypt.hashCode ^
      cipherModel.hashCode ^
      finger.hashCode ^
      punchModel.hashCode ^
      ports.hashCode ^
      firstLatency.hashCode ^
      deviceName.hashCode ^
      useChannelType.hashCode ^
      packetLossRate.hashCode ^
      packetDelay.hashCode ^
      portMappingList.hashCode ^
      compressor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VntConfig &&
          runtimeType == other.runtimeType &&
          tap == other.tap &&
          token == other.token &&
          deviceId == other.deviceId &&
          name == other.name &&
          serverAddressStr == other.serverAddressStr &&
          nameServers == other.nameServers &&
          stunServer == other.stunServer &&
          inIps == other.inIps &&
          outIps == other.outIps &&
          password == other.password &&
          mtu == other.mtu &&
          ip == other.ip &&
          noProxy == other.noProxy &&
          serverEncrypt == other.serverEncrypt &&
          cipherModel == other.cipherModel &&
          finger == other.finger &&
          punchModel == other.punchModel &&
          ports == other.ports &&
          firstLatency == other.firstLatency &&
          deviceName == other.deviceName &&
          useChannelType == other.useChannelType &&
          packetLossRate == other.packetLossRate &&
          packetDelay == other.packetDelay &&
          portMappingList == other.portMappingList &&
          compressor == other.compressor;
}
